# Root Terragrunt configuration
# This file contains shared configuration that can be inherited by all environments and layers

locals {
  # Import global configuration
  global = read_terragrunt_config(find_in_parent_folders("global.hcl")).locals
  
  # Extract path components for naming
  # Path format: live/{env}/{region}/{layer}/{resource}
  path_parts = split("/", get_terragrunt_dir())
  
  # Find the "live" directory index for consistent parsing
  live_index = try(
    index(local.path_parts, "live"),
    -1
  )
  
  # Validate that we found "live" directory
  has_live_dir = local.live_index >= 0
  
  # Extract environment and region relative to "live" directory
  environment = local.has_live_dir ? try(
    local.path_parts[local.live_index + 1],
    get_env("ENVIRONMENT", "dev")
  ) : get_env("ENVIRONMENT", "dev")
  
  region = local.has_live_dir ? try(
    local.path_parts[local.live_index + 2],
    get_env("AWS_REGION", "us-east-1")
  ) : get_env("AWS_REGION", "us-east-1")
  
  # Get layer and resource (optional, for enhanced naming)
  layer = local.has_live_dir ? try(
    local.path_parts[local.live_index + 3],
    "unknown"
  ) : "unknown"
  
  resource_name = local.has_live_dir ? try(
    local.path_parts[local.live_index + 4],
    "default"
  ) : "default"
  
  # Use global region mapping for consistent short codes
  region_short = try(
    local.global.region_short_map[local.region],
    "unknown"
  )
  
  # Standard resource naming using global project name
  resource_prefix = "${local.global.project_name}-${local.environment}-${local.region_short}"
  resource_name_standard = "${local.resource_prefix}-${local.resource_name}"
  
  # Short resource name  
  short_name = "${local.environment}-${local.region_short}-${local.resource_name}"
  
  # Common tags applied to all resources - merge global + local
  common_tags_base = merge(
    local.global.base_tags,
    {
      Environment = local.environment
      Region      = local.region
      Layer       = local.layer
      Repository  = "aws-terragrunt-iac"
    }
  )
  
  # Environment-specific tags
  environment_tags_dev = {
    CostCenter = "development"
    Owner      = "platform-team"
  }
  
  environment_tags_staging = {
    CostCenter = "staging"
    Owner      = "platform-team"
  }
  
  environment_tags_prod = {
    CostCenter = "production"
    Owner      = "platform-team"
    Backup     = "required"
  }
  
  # Final tags based on environment
  common_tags = local.environment == "dev" ? merge(local.common_tags_base, local.environment_tags_dev) : (
    local.environment == "staging" ? merge(local.common_tags_base, local.environment_tags_staging) : 
    merge(local.common_tags_base, local.environment_tags_prod)
  )
}

# Configure Terragrunt to automatically store tfstate files in an S3 bucket
# Note: Layer 0 Foundation must be deployed first to create the S3 bucket and DynamoDB table
remote_state {
  backend = "s3"
  config = {
    bucket         = get_env("TF_STATE_BUCKET", "${local.resource_prefix}-state")
    key            = "${path_relative_to_include()}/terraform.tfstate"
    region         = local.region
    encrypt        = true
    dynamodb_table = get_env("TF_LOCK_TABLE", "${local.resource_prefix}-locks")
  }
}

# Note: Provider configuration is generated by child configs as needed
# This avoids conflicts with modules that already define required_providers
# Child configs should generate provider.tf if the module doesn't have it

# Inputs that can be overridden by child configurations
inputs = {
  # Naming conventions
  naming_convention = {
    resource_name        = local.resource_name_standard
    short_name          = local.short_name
    s3_bucket           = "${local.global.project_name}-${local.environment}-${local.region_short}-${local.resource_name}"
    dynamodb_table      = "${local.global.project_name}-${local.environment}-${local.region_short}-${local.resource_name}"
    kms_alias           = "alias/${local.global.project_name}/${local.environment}/${local.region_short}/${local.resource_name}"
    iam_role            = "${substr(local.global.project_name, 0, 8)}-${local.environment}-${substr(local.region_short, 0, 6)}-${substr(local.resource_name, 0, 10)}-role"
    security_group      = "${local.global.project_name}-${local.environment}-${local.region_short}-${local.resource_name}-sg"
    cloudwatch_log_group = "/aws/${local.global.project_name}/${local.environment}/${local.region_short}/${local.resource_name}"
    eks_cluster         = "${local.environment}-${local.region_short}-${local.resource_name}"
    vpc                 = "${local.global.project_name}-${local.environment}-${local.region_short}-vpc"
  }
  
  # Common tags (automatically includes environment-specific tags)
  common_tags = local.common_tags
  
  # Environment and region
  environment  = local.environment
  aws_region   = local.region
  region_short = local.region_short
  layer        = local.layer
  project_name = local.global.project_name
}

